#!/usr/bin/env python
from argparse import ArgumentParser
import glob
import os
import time
import sys
import yaml

from tabulate import tabulate

from tagpack import __version__ as version
from tagpack.cassandra import Cassandra, BATCH_SIZE_LIMIT
from tagpack.taxonomy import Taxonomy
from tagpack.tagpack import TagPack
from tagpack.tagpack_schema import TagPackSchema, ValidationError

CONFIG_FILE = "config.yaml"

DEFAULT_KEYSPACE = "tagpacks"


class bcolors:
    HEADER = '\033[1;97m'
    INFO = '\033[1;97m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


rows, columns = os.popen('stty size', 'r').read().split()
columns = int(columns)


def print_separator(symbol, text, colour=None):
    left = int((columns - len(text) - 2) / 2)
    right = columns - left - len(text) - 2
    if colour:
        print(f"{colour}", end='')
    print(symbol * left, text, symbol * right)
    if colour:
        print(f"{bcolors.ENDC}", end='')


def remote_load_taxonomies():
    taxonomies = {}
    for key in CONFIG['taxonomies']:
        taxonomy = remote_load_taxonomy(key)
        taxonomies[key] = taxonomy
    return taxonomies


def remote_load_taxonomy(key):
    uri = CONFIG['taxonomies'][key]
    taxonomy = Taxonomy(key, uri)
    taxonomy.load_from_remote()
    return taxonomy


def show_taxonomy(args):
    print("Showing concepts of taxonomy {}".format(args.taxonomy))
    taxonomy = remote_load_taxonomy(args.taxonomy)
    if args.verbose:
        headers = ['Id', 'Label', 'Uri', 'Description']
        table = [[c.id, c.label, c.uri, c.description]
                 for c in taxonomy.concepts]
    else:
        headers = ['Id', 'Label']
        table = [[c.id, c.label] for c in taxonomy.concepts]

    print(tabulate(table, headers=headers))


def ingest_taxonomy(args):
    cassandra = Cassandra(args.db_nodes)
    try:
        cassandra.connect()

        if not cassandra.has_keyspace(args.keyspace):
            print("Keyspace {} does not exist. Please create manually first"
                  .format(args.keyspace))
            sys.exit()

        taxonomy = remote_load_taxonomy(args.taxonomy)
        cassandra.insert_taxonomy(taxonomy, args.keyspace)

    except Exception as e:
        print(e)
    finally:
        cassandra.close()
        sys.exit()


def taxonomy(args):
    list_taxonomies()


def load_config():
    if not os.path.isfile(CONFIG_FILE):
        sys.exit("This program requires a repository config file in {}"
                 .format(os.getcwd()))
    return yaml.safe_load(open(CONFIG_FILE, 'r'))


def list_taxonomies():
    print("Taxonomies:")
    for key, value in CONFIG['taxonomies'].items():
        print(key, value)


def show_config(args):
    print("Config File:", os.path.abspath(CONFIG_FILE))
    if args.verbose:
        print("BaseURI:", CONFIG['baseURI'])
        list_taxonomies()


def collect_tagpacks(paths):
    """Collect Tagpack YAML files from given paths"""
    tagpacks = []
    for path in paths:
        if os.path.isdir(path):
            files = glob.glob(path + '/**/*.yaml', recursive=True)
            tagpacks = tagpacks + files
        elif os.path.isfile(path):
            tagpacks.append(path)
    return tagpacks


def validate(args):
    t0 = time.time()
    print_separator('=', "TagPack validation starts", bcolors.HEADER)
    print(f"Path: {args.path}")

    taxonomies = remote_load_taxonomies()
    taxonomy_keys = [key for key in taxonomies.keys()]
    print(f"Loaded taxonomies: {taxonomy_keys}")

    schema = schema = TagPackSchema()
    print(f"Loaded schema: {schema.definition}")

    tagpacks = collect_tagpacks(args.path)
    print(f"{bcolors.INFO}Collected TagPacks: {len(tagpacks)}{bcolors.ENDC}",
          '\n')

    no_passed = 0
    for tagpack in tagpacks:
        tagPack = TagPack(CONFIG['baseURI'], tagpack, schema)
        try:
            schema.validate(tagPack, taxonomies)
            print(f'{tagpack}: {bcolors.OKGREEN}PASSED{bcolors.ENDC}')
            no_passed += 1
        except ValidationError as e:
            print(f'{tagpack}: {bcolors.FAIL}FAILED{bcolors.ENDC}', e)

    if no_passed < len(tagpacks):
        colour = bcolors.FAIL
    else:
        colour = bcolors.OKGREEN

    duration = round(time.time() - t0, 2)
    print_separator(
        '=',
        f"{no_passed}/{len(tagpacks)} TagPacks passed in {duration}s",
        colour)


def ingest(args):
    print("Called ingest with {}".format(args.folders))


def main():
    parser = ArgumentParser(
        description='TagPack validation and ingest tool',
        epilog='GraphSense TagPack Tool v{}- https://graphsense.info'
        .format(version))
    parser.add_argument('-v', '--version', action='version', version=version)

    subparsers = parser.add_subparsers(title='Commands')

    # parser for taxonomy command
    parser_t = subparsers.add_parser("taxonomy",
                                     help="show taxonomy concepts")
    parser_t.add_argument('taxonomy', nargs='?', metavar='TAXONOMY_KEY',
                          help='fetch and display taxonomy concepts')
    parser_t.set_defaults(func=taxonomy)

    parser_t_subparsers = parser_t.add_subparsers(title='Taxonomy commands')

    # parser for taxonomy ingest command
    parser_t_i = parser_t_subparsers.add_parser(
        'ingest', help='ingest taxonomy into GraphSense')
    parser_t_i.add_argument('-d', '--db_nodes', nargs='+',
                            default=['localhost'], metavar='DB_NODE',
                            help='Cassandra nodes; default "localhost")')
    parser_t_i.add_argument('-k', '--keyspace', nargs=1,
                            default=DEFAULT_KEYSPACE, metavar='KEYSPACE',
                            help="Cassandra keyspace for taxomy tables")
    parser_t_i.set_defaults(func=ingest_taxonomy)

    # parser for taxonomy ingest command
    parser_t_s = parser_t_subparsers.add_parser(
        'show', help='show taxonomy concepts')
    parser_t_s.add_argument('-v', '--verbose', action='store_true',
                            help="verbose concepts")
    parser_t_s.set_defaults(func=show_taxonomy)

    # parser for config command
    parser_c = subparsers.add_parser("config",
                                     help="show TagPack Repository config")
    parser_c.add_argument('-v', '--verbose', action='store_true',
                          help='verbose configuration')
    parser_c.set_defaults(func=show_config)

    # parser for ingest command
    parser_i = subparsers.add_parser("ingest",
                                     help="ingest TagPacks into GraphSense")
    parser_i.add_argument('-f', '--folders', nargs='+', metavar='FOLDER',
                          default=[os.getcwd()],
                          help='TagPacks root folder; default "./"')
    parser_i.add_argument('-d', '--db_nodes', nargs='+', default='127.0.0.1',
                          metavar='DB_NODE',
                          help='Cassandra nodes; default "localhost")')
    parser_i.add_argument('-b', '--batch_size', nargs='?',
                          default=BATCH_SIZE_LIMIT,
                          help='batch size for inserting tags into Cassandra)')
    parser_i.set_defaults(func=ingest)

    # parser for validate command
    parser_v = subparsers.add_parser("validate", help="validate TagPacks")
    parser_v.add_argument('path', nargs='+', metavar='PATH',
                          default=[os.getcwd()],
                          help='TagPacks path')
    parser_v.add_argument('-r', '--recursive', action='store_true',
                          help='Recursively traverse path')
    parser_v.set_defaults(func=validate)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    if (sys.version_info < (3, 6)):
        sys.exit("This program requires python version 3.6 or later")

    global CONFIG
    CONFIG = load_config()

    # t0 = time.time()
    main()
    # print('Total time:', time.time() - t0)
